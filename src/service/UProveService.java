/**
 * UProveService.java
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright (C) Pim Vullers, Radboud University Nijmegen, January 2010.
 */

package service;

import java.io.IOException;
import java.math.BigInteger;
import java.util.Arrays;

import javax.smartcardio.CommandAPDU;
import javax.smartcardio.ResponseAPDU;

import com.microsoft.uprove.IssuerParameters;
import com.microsoft.uprove.PresentationProof;
import com.microsoft.uprove.PrimeOrderGroup;
import com.microsoft.uprove.Prover;
import com.microsoft.uprove.ProverProtocolParameters;
import com.microsoft.uprove.Subgroup;
import com.microsoft.uprove.UProveKeyAndToken;
import com.microsoft.uprove.UProveToken;

import net.sourceforge.scuba.smartcards.CardService;
import net.sourceforge.scuba.smartcards.CardServiceException;
import net.sourceforge.scuba.smartcards.ISO7816;
import net.sourceforge.scuba.util.Hex;

/**
 * U-Prove Smart Card Interface based on a SCUBA Card Service.
 *  
 * @author Pim Vullers
 * @version $Revision: 554 $ by $Author: pim $
 *          $LastChangedDate: 2011-04-28 16:31:47 +0200 (Thu, 28 Apr 2011) $
 */
public class UProveService extends CardService implements Prover {
    /**
     * Control the amount of output generated by this class.
     */
    private static final boolean VERBOSE = true;

    /**
     * Universal version identifier to match versions during deserialisation.
     */
    private static final long serialVersionUID = -8522592878770927211L;

    /**
     * AID of the U-Prove applet: ASCII encoding of "uprove".
     */
    private static final byte[] AID = {0x75, 0x70, 0x72, 0x6F, 0x76, 0x65};

    /**
     * CLAss to be used for U-Prove APDUs.
     */
    private static final byte CLA_UPROVE = 0x00;

    /**
     * INStruction to select an applet.
     */
    private static final byte INS_SELECT = (byte) 0xA4;

    /**
     * INStruction to set the various test modes of the card (on, off, reset).
     */
    private static final byte INS_TESTMODE = (byte) 0xFF;

    /**
     * INStruction to perform precomputation of x_t, gamma and sigma_z.
     */
    private static final byte INS_PRECOMPUTE_INPUTS = 0x0D;

    /**
     * INStruction to perform issuing precomputations.
     * 
     * @protocol token issuance.
     */
    private static final byte INS_PRECOMPUTE = 0x11;

    /**
     * INStruction to send the first commitment (sigma_a). 
     * 
     * @protocol token issuance.
     */
    private static final byte INS_COMMIT_SIGMA_A = 0x12;

    /**
     * INStruction to send the second commitment (sigma_b) and compute/receive 
     * the challenge (sigma_c). 
     * 
     * @protocol token issuance.
     */
    private static final byte INS_COMMIT_SIGMA_B = 0x13;

    /**
     * INStruction to send the response (sigma_r) which provides the signature. 
     * 
     * @protocol token issuance.
     */
    private static final byte INS_SIGNATURE_SIGMA_R = 0x14;

    /**
     * INStruction to send the list of attributes to be disclosed (D).
     * 
     * @protocol attribute disclosure / presentation proof generation. 
     */
    private static final byte INS_ATTRIBUTE_DISCLOSURE = 0x20;

    /**
     * INStruction to send the challenge (m) to be signed in the proof and 
     * receive the commitment for the proof (a). 
     * 
     * @protocol attribute disclosure / presentation proof generation. 
     */
    private static final byte INS_CHALLENGE = 0x21;

    /**
     * INStruction to receive the disclosed attributes (A_i).
     * 
     * @protocol attribute disclosure / proof generation. 
     */
    private static final byte INS_DISCLOSED_ATTRIBUTES = 0x22;

    /**
     * INStruction to receive the values for the undisclosed attributes (r_i). 
     * 
     * @protocol attribute disclosure / proof generation. 
     */
    private static final byte INS_UNDISCLOSED_ATTRIBUTES = 0x23;

    /**
     * INStruction to receive the public key (h) of the U-Prove token and the 
     * issuer signature (sigma_z', sigma_c', sigma_r') on the U-Prove token.
     *  
     * @protocol attribute disclosure / proof generation. 
     */
    private static final byte INS_GET_TOKEN = 0x24;

    /**
     * Initialisation instructions (getters)
     */
    private static final byte INS_SET_NUMBER_OF_TOKENS = 0x00;
    private static final byte INS_SET_PARAMETERS_UID = 0x01;
    private static final byte INS_SET_GROUP = 0x02;
    private static final byte INS_SET_HASH_ALGORITHM_UID = 0x03;
    private static final byte INS_SET_PUBLIC_KEY_ELEMENTS = 0x04;
    private static final byte INS_SET_ENCODING_BYTES = 0x05;
    private static final byte INS_SET_ISSUANCE_VALUES = 0x06;
    private static final byte INS_SET_SPECIFICATION = 0x07;
    private static final byte INS_SET_ATTRIBUTES = 0x08;
    private static final byte INS_SET_TOKEN_INFORMATION = 0x09;
    private static final byte INS_SET_PROVER_INFORMATION = 0x0A;
    private static final byte INS_SET_ATTRIBUTE_VALUES = 0x0B;

    /**
     * Retrieval instructions (getters)
     */
    private static final byte INS_GET_NUMBER_OF_TOKENS = 0x30;
    private static final byte INS_GET_PARAMETERS_UID = 0x31;
    private static final byte INS_GET_GROUP = 0x32;
    private static final byte INS_GET_HASH_ALGORITHM_UID = 0x33;
    private static final byte INS_GET_PUBLIC_KEY_ELEMENTS = 0x34;
    private static final byte INS_GET_ENCODING_BYTES = 0x35;
    private static final byte INS_GET_ISSUANCE_VALUES = 0x36;
    private static final byte INS_GET_SPECIFICATION = 0x37;
    private static final byte INS_GET_ATTRIBUTES = 0x38;
    private static final byte INS_GET_TOKEN_INFORMATION = 0x39;
    private static final byte INS_GET_PROVER_INFORMATION = 0x3A;
    private static final byte INS_GET_ATTRIBUTE_VALUES = 0x3B;
    private static final byte INS_GET_NUMBER_OF_ATTRIBUTES = 0x3C;

    /**
     * P1 parameter to indicate the group prime (p).
     */
    private static final byte P1_GROUP_P = 0x00;

    /**
     * P1 parameter to indicate the group order (q).
     */
    private static final byte P1_GROUP_Q = 0x01;

    /**
     * P1 parameter to indicate the group generator (g).
     */
    private static final byte P1_GROUP_G = 0x02;

    /**
     * P1 parameter to indicate the token public key (h).
     */
    private static final byte P1_TOKEN_H = 0x00;

    /**
     * P1 parameter to indicate the issuer signature (sigma_z').
     */
    private static final byte P1_TOKEN_SIGMA_Z = 0x01;

    /**
     * P1 parameter to indicate the issuer signature (sigma_c').
     */
    private static final byte P1_TOKEN_SIGMA_C = 0x02;

    /**
     * P1 parameter to indicate the issuer signature (sigma_r').
     */
    private static final byte P1_TOKEN_SIGMA_R = 0x03;

    /**
     * SCUBA service to communicate with the card.
     */
    protected CardService service;

    /**************************************************************************/
    /* SCUBA / Smart Card Setup                                               */
    /**************************************************************************/

    /**
     * Construct a new U-Prove service based on some CardService, which will be
     * used for the actual communication with a U-Prove applet.
     * 
     * @param service the service to use for communication with the applet.
     */
    public UProveService(CardService service) {
        this.service = service;
    }

    /**
     * Open a communication channel to a U-Prove applet.
     */
    public void open() 
    throws CardServiceException {
        if (!isOpen()) {
            service.open();
        }
        selectApplet();
    }

    /**
     * Check whether a communication channel with a smart card exists.
     * 
     * @return whether the channel is open or not.
     */
    public boolean isOpen() {
        return service.isOpen();
    }

    /**
     * Send an APDU over the communication channel to the smart card.
     * 
     * @param apdu the APDU to be send to the smart card.
     * @return ResponseAPDU the response from the smart card.
     * @throws CardServiceException if some error occurred while transmitting.
     */
    public ResponseAPDU transmit(CommandAPDU capdu) 
    throws CardServiceException { 

        if (VERBOSE) {
            System.out.println();
            System.out.println("C: " + Hex.bytesToHexString(capdu.getBytes()));    		
        }

        long start = System.nanoTime();
        ResponseAPDU rapdu = service.transmit(capdu);
        long duration = (System.nanoTime() - start)/1000000;

        if (VERBOSE) {
            System.out.println(" duration: " + duration + " ms");
            System.out.println("R: " + Hex.bytesToHexString(rapdu.getBytes()));
        }

        return rapdu;
    }

    /**
     * Close the communication channel with the U-Prove applet.
     */
    public void close() {
        if (service != null) {
            service.close();
        }
    }

    /**
     * Select the U-Prove applet on the smart card.
     * 
     * @throws CardServiceException if an error occurred.
     */
    public void selectApplet() 
    throws CardServiceException {
        CommandAPDU select = new CommandAPDU(ISO7816.CLA_ISO7816,  
                INS_SELECT, 0x04, 0x00, AID, 256); // LE == 0 is required.
        ResponseAPDU response = transmit(select);
        if (response.getSW() != 0x00009000) {
            throw new CardServiceException("Could not select the U-Prove " +
                    "applet.", response.getSW());
        }
    }


    /**
     * Configure the test mode of the smart card.
     * 
     * @param mode the test mode (0x00 is off, 0x01 is on, 0x02 is clear).
     * @throws CardServiceException if an error occurred.
     */
    public void testMode(byte mode)
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_TESTMODE, mode, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            throw new CardServiceException("Could not set test mode.", 
                    response.getSW());
        }       
    }

    /**
     * Report about commands not supported by the smart card. 
     */
    protected void notSupported(String message) {
        System.err.println();
        System.err.println(message);
        System.err.println("This command is NOT supported by the smart card.");
        System.err.println();
    }

    /**
     * Produces an unsigned byte-array representation of a BigInteger.
     *
     * <p>BigInteger adds an extra sign bit to the beginning of its byte
     * array representation.  In some cases this will cause the size
     * of the byte array to increase, which may be unacceptable for some
     * applications. This function returns a minimal byte array representing
     * the BigInteger without extra sign bits.
     *
     * <p>This method is taken from the Network Security Services for Java (JSS)
     * currently maintained by the Mozilla Foundation and originally developed 
     * by the Netscape Communications Corporation.
     * 
     * @return unsigned big-endian byte array representation of a BigInteger.
     */
    public static byte[] BigIntegerToUnsignedByteArray(BigInteger big) {
        byte[] ret;

        // big must not be negative
        assert(big.signum() != -1);

        // bitLength is the size of the data without the sign bit.  If
        // it exactly fills an integral number of bytes, that means a whole
        // new byte will have to be added to accommodate the sign bit. In
        // this case we need to remove the first byte.
        if(big.bitLength() % 8 == 0) {
            byte[] array = big.toByteArray();
            // The first byte should just be sign bits
            assert( array[0] == 0 );
            ret = new byte[array.length-1];
            System.arraycopy(array, 1, ret, 0, ret.length);
        } else {
            ret = big.toByteArray();
        }
        return ret;
    }
    
    /**
     * Fix the length of arrays put into the APDUs.
     * 
     * @param array of which the length needs to be fixed.
     * @return an array with a fixed length.
     */
    public static byte[] fixLength(byte[] array) {        
        if (array.length % 4 == 0) {
            return array;
        } else {
            int padding = 4 - array.length % 4;
            byte[] fixed = new byte[array.length + padding];
            Arrays.fill(fixed, (byte) 0x00);
            System.arraycopy(array, 0, fixed, padding, array.length);
            return fixed;
        }
    }

    /**************************************************************************/
    /* U-Prove Smart Card Interface                                           */
    /**************************************************************************/

    /**
     * Set the parameters for the prover: 
     * 
     * <ul>
     *   <li> number of tokens, 
     *   <li> issuer parameters, 
     *   <li> token attributes,
     *   <li> token information, and 
     *   <li> prover information.
     * </ul>
     * 
     * @param params the parameters to be set.
     * @throws CardServiceException if an error occurred.
     */
    public void setProverProtocolParameters(ProverProtocolParameters params) 
    throws CardServiceException {
        // number of tokens
        setNumberOfTokens(params.getNumberOfTokens());

        // issuer parameters
        setIssuerParameters(params.getIssuerParameters());

        // token attributes
        setAttributes(params.getTokenAttributes());

        // token information field
        setTokenInformation(params.getTokenInformation());

        // prover information field
        setProverInformation(params.getProverInformation());
    }

    /**
     * Get the parameters of the prover:
     * 
     * <ul>
     *   <li> number of tokens, 
     *   <li> issuer parameters, 
     *   <li> token attributes,
     *   <li> token information, and 
     *   <li> prover information.
     * </ul>
     * 
     * @return the parameters of the prover.
     * @throws CardServiceException if an error occurred.
     */
    public ProverProtocolParameters getProverProtocolParameters() 
    throws CardServiceException {
        ProverProtocolParameters params = new ProverProtocolParameters();

        // number of tokens
        params.setNumberOfTokens(getNumberOfTokens());

        // issuer parameters
        params.setIssuerParameters(getIssuerParameters());

        // token attributes
        params.setTokenAttributes(getAttributes());

        // token information field
        params.setTokenInformation(getTokenInformation());

        // prover information field
        params.setProverInformation(getProverInformation());

        return params;
    }

    /**
     * Set the number of tokens to work with.
     * 
     * @param numberOfTokens the number of tokens.
     * @throws CardServiceException if an error occurred.
     */
    void setNumberOfTokens(int numberOfTokens) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_NUMBER_OF_TOKENS, 0x00, 0x00, 
                new byte[] {(byte)numberOfTokens});
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set number of tokens.");
            } else {
                throw new CardServiceException("Could not set number of " +
                        "tokens.", response.getSW());
            }
        }	
    }

    /**
     * Get the number of tokens available.
     * 
     * @return the number of tokens, or 1 if not supported.
     * @throws CardServiceException if an error occurred.
     */
    int getNumberOfTokens() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_NUMBER_OF_TOKENS, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not get number of tokens.");
                return 1;
            } else {
                throw new CardServiceException("Could not get number of " +
                        "tokens.", response.getSW());
            }
        }

        return Hex.hexStringToInt(Hex.toHexString(response.getData()));
    }

    /**
     * Set the issuer parameters:
     * 
     * <ul>
     *   <li> parameters UID, 
     *   <li> group, 
     *   <li> hash algorithm UID, 
     *   <li> public key elements, 
     *   <li> encoding bytes, 
     *   <li> prover issuance values, and 
     *   <li> specification.
     * </ul>
     * 
     * @param issuerParameters the parameters to be set.
     * @throws CardServiceException if a an error occurred on the card.
     */
    public void setIssuerParameters(IssuerParameters issuerParameters) 
    throws CardServiceException {
        // parameters UID
        setParametersUID(issuerParameters.getParametersUID());

        // the prime order group
        setGroup(issuerParameters.getGroup());

        // the hash algorithm UID
        setHashAlgorithmUID(issuerParameters.getHashAlgorithmUID());

        // public key elements
        setPublicKey(issuerParameters.getPublicKey());	

        // the hash booleans
        setEncodingBytes(issuerParameters.getEncodingBytes());

        // prover's issuance values
        setProverIssuanceValues(issuerParameters.getProverIssuanceValues());

        // the specification
        setSpecification(issuerParameters.getSpecification());
    }

    /**
     * Get the issuer parameters:
     * 
     * <ul>
     *   <li> parameters UID, 
     *   <li> group, 
     *   <li> hash algorithm UID, 
     *   <li> public key elements, 
     *   <li> encoding bytes, 
     *   <li> prover issuance values, and 
     *   <li> specification.
     * </ul>
     * 
     * @return the issuer parameters.
     * @throws CardServiceException if a an error occurred on the card.
     */
    public IssuerParameters getIssuerParameters() 
    throws CardServiceException {
        IssuerParameters issuerParameters = new IssuerParameters();

        // parameters UID
        issuerParameters.setParametersUID(getParametersUID());

        // the prime order group
        issuerParameters.setGroup(getGroup());

        // the hash algorithm UID
        issuerParameters.setHashAlgorithmUID(getHashAlgorithmUID());

        // public key elements
        issuerParameters.setPublicKey(getPublicKey());	

        // the hash booleans
        issuerParameters.setEncodingBytes(getEncodingBytes());

        // prover's issuance values
        issuerParameters.setProverIssuanceValues(getProverIssuanceValues());

        // the specification
        issuerParameters.setSpecification(getSpecification());

        return issuerParameters;
    }

    /**
     * Set the application-specific unique identifier for the Issuer parameters:
     * 
     * <pre>
     *   UID_P
     * </pre>
     * 
     * @param parametersUID the UID to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setParametersUID(byte[] parametersUID) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_PARAMETERS_UID, 0x00, 0x00, parametersUID);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set parameters UID.");
            } else {
                throw new CardServiceException("Could not set parameters UID.", 
                        response.getSW());
            }
        }
    }

    /**
     * Get the application-specific unique identifier for the Issuer parameters:
     * 
     * <pre>
     *   UID_P
     * </pre>
     * 
     * @return the parameters UID, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[] getParametersUID() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_PARAMETERS_UID, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not get parameters UID.");
                return null;
            } else {
                throw new CardServiceException("Could not get parameters UID.", 
                        response.getSW());
            }
        }

        return response.getData();
    }

    /**
     * Set the DL-subgroup G_q of prime order q of a finite field of order p:
     * 
     * <pre>
     *   (p, q, g)
     * </pre>
     * 
     * @param group the group to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setGroup(PrimeOrderGroup group) 
    throws CardServiceException {
        if (group instanceof Subgroup) {
            Subgroup subgroup = (Subgroup)group;

            // p (P1 == 0x00)
            byte[] p = BigIntegerToUnsignedByteArray(subgroup.getP());
            CommandAPDU command_p = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_GROUP, P1_GROUP_P, 0x00, fixLength(p));
            ResponseAPDU response_p = transmit(command_p);
            if (response_p.getSW() != 0x00009000) {
                if (response_p.getSW() == 0x00006D00) {
                    notSupported("Could not set group prime p.");
                } else {
                    throw new CardServiceException("Could not set group " +
                            "prime p.",	response_p.getSW());
                }
            }

            // q (P1 == 0x01)
            byte[] q = BigIntegerToUnsignedByteArray(subgroup.getQ());
            CommandAPDU command_q = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_GROUP, P1_GROUP_Q, 0x00, fixLength(q)); 
            ResponseAPDU response_q = transmit(command_q);
            if (response_q.getSW() != 0x00009000) {
                if (response_q.getSW() == 0x00006D00) {
                    notSupported("Could not set group order q.");
                } else {
                    throw new CardServiceException("Could not set group " +
                            "order q.", response_q.getSW());
                }
            }

            // g (P1 == 0x02)
            byte[] g = BigIntegerToUnsignedByteArray(subgroup.getG());
            CommandAPDU command_g = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_GROUP, P1_GROUP_G, 0x00, fixLength(g));
            ResponseAPDU response_g = transmit(command_g);
            if (response_g.getSW() != 0x00009000) {
                if (response_g.getSW() == 0x00006D00) {
                    notSupported("Could not set generator g.");
                } else {
                    throw new CardServiceException("Could not set generator g.",
                            response_g.getSW());
                }
            }
        } else {
            // These values cannot be extracted from a generic PrimeOrderGroup
            throw new CardServiceException("Don't know how to set group.");
        }
    }

    /**
     * Get the DL-subgroup G_q of prime order q of a finite field of order p:
     * 
     * <pre>
     *   (p, q, g)
     * </pre>
     * 
     * @return the prime order subgroup, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    PrimeOrderGroup getGroup() 
    throws CardServiceException {
        // p (P1 == 0x00)
        CommandAPDU command_p = new CommandAPDU(CLA_UPROVE, 
                INS_GET_GROUP, P1_GROUP_P, 0x00);
        ResponseAPDU response_p = transmit(command_p);
        if (response_p.getSW() != 0x00009000) {
            if (response_p.getSW() == 0x00006D00) {
                notSupported("Could not get group prime p.");
                return null;
            } else {
                throw new CardServiceException("Could not get group prime p.", 
                        response_p.getSW());
            }
        }

        // q (P1 == 0x01)
        CommandAPDU command_q = new CommandAPDU(CLA_UPROVE, 
                INS_GET_GROUP, P1_GROUP_Q, 0x00);
        ResponseAPDU response_q = transmit(command_q);
        if (response_q.getSW() != 0x00009000) {
            if (response_q.getSW() == 0x00006D00) {
                notSupported("Could not get group order q.");
                return null;
            } else {
                throw new CardServiceException("Could not get group order q.", 
                        response_q.getSW());
            }
        }

        // g (P1 == 0x02)
        CommandAPDU command_g = new CommandAPDU(CLA_UPROVE, 
                INS_GET_GROUP, P1_GROUP_G, 0x00);
        ResponseAPDU response_g = transmit(command_g);
        if (response_g.getSW() != 0x00009000) {
            if (response_g.getSW() == 0x00006D00) {
                notSupported("Could not get generator g.");
                return null;
            } else {
                throw new CardServiceException("Could not get generator g.", 
                        response_g.getSW());
            }
        }

        return new Subgroup(response_p.getData(), response_q.getData(), 
                response_g.getData());
    }

    /**
     * Set the identifier of the cryptographically secure hash algorithm: 
     * 
     * <pre>
     *   UID_H
     * </pre>
     * 
     * @param hashAlgorithmUID the UID to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setHashAlgorithmUID(String hashUID) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_HASH_ALGORITHM_UID, 0x00, 0x00, hashUID.getBytes());
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set hash algorithm UID.");
            } else {
                throw new CardServiceException("Could not set hash algorithm " +
                        "UID.",	response.getSW());
            }
        }
    }

    /**
     * Get the identifier of the cryptographically secure hash algorithm: 
     * 
     * <pre>
     *   UID_H
     * </pre>
     * 
     * @return the hash algorithm UID, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    String getHashAlgorithmUID() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_HASH_ALGORITHM_UID, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not get hash algorithm UID.");
                return null;
            } else {
                throw new CardServiceException("Could not get hash algorithm " +
                        "UID.", response.getSW());
            }
        }

        return Hex.bytesToASCIIString(response.getData());
    }

    /**
     * Set the Issuer's public key: 
     * 
     * <pre>
     *   g_0, g_1, ..., g_n, g_t
     * </pre>
     * 
     * @param pubKey the public key to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setPublicKey(byte[][] pubKey) 
    throws CardServiceException {
        for (int i = 0; i < pubKey.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_PUBLIC_KEY_ELEMENTS, i, pubKey.length, 
                    fixLength(pubKey[i]));
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not set public key elements.");
                } else {
                    throw new CardServiceException("Could not set public key " +
                            "element (@index " + i + ").", response.getSW());
                }
            }
        }
    }

    /**
     * Get the Issuer's public key: 
     * 
     * <pre>
     *   g_0, g_1, ..., g_n, g_t
     * </pre>
     * 
     * @return the public key, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[][] getPublicKey() 
    throws CardServiceException {
        byte[][] pubKey = new byte[getNumberOfAttributes() + 2][];

        for (int i = 0; i < pubKey.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_GET_PUBLIC_KEY_ELEMENTS, i, pubKey.length);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not get public key elements.");
                    return null;
                } else {
                    throw new CardServiceException("Could not get public key " +
                            "element (@index " + i + ").", response.getSW());
                }
            }
            pubKey[i] = response.getData();
        }

        return pubKey;
    }

    /**
     * Set the encoding bytes which indicate whether or not the attribute values
     * are hashed when computing a U-Prove token public key: 
     * 
     * <pre>
     *   e_1, ..., e_n
     * </pre>
     * 
     * @param encodingBytes the encoding bytes to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setEncodingBytes(byte[] encodingBytes) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_ENCODING_BYTES, 0x00, 0x00, encodingBytes);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set encoding bytes.");
            } else {
                throw new CardServiceException("Could not set encoding bytes.", 
                        response.getSW());
            }
        }
    }

    /**
     * Get the encoding bytes which indicate whether or not the attribute values
     * are hashed when computing a U-Prove token public key: 
     * 
     * <pre>
     *   e_1, ..., e_n
     * </pre>
     * 
     * @return the encoding bytes, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[] getEncodingBytes() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_ENCODING_BYTES, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not get encoding bytes.");
                return null;
            } else {
                throw new CardServiceException("Could not get encoding bytes.", 
                        response.getSW());
            }
        }

        return response.getData();
    }

    /**
     * Set the values needed by the Prover in the issuance protocol: 
     * 
     * <pre>
     *   z_0, z_1, ..., z_n, z_t
     * </pre>
     * 
     * @param values the prover issuance values to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setProverIssuanceValues(byte[][] values) 
    throws CardServiceException {
        for (int i = 0; i < values.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_ISSUANCE_VALUES, i, values.length, 
                    fixLength(values[i]));
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not set prover issuance values.");
                } else {
                    throw new CardServiceException("Could not set prover " +
                            "issuance value (@index " + i + ").", 
                            response.getSW());
                }
            }	    
        }
    }

    /**
     * Get the values needed by the Prover in the issuance protocol: 
     * 
     * <pre>
     *   z_0, z_1, ..., z_n, z_t
     * </pre>
     * 
     * @return the prover issuance values, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[][] getProverIssuanceValues() 
    throws CardServiceException {
        byte[][] values = new byte[getNumberOfAttributes() + 2][]; 

        for (int i = 0; i < values.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_GET_ISSUANCE_VALUES, i, values.length);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not get prover issuance values.");
                    return null;
                } else {
                    throw new CardServiceException("Could not get prover " +
                            "issuance value (@index " + i + ").", 
                            response.getSW());
                }
            }
            values[i] = response.getData();
        }

        return values;
    }

    /**
     * Set the application-specific specification: 
     * 
     * <pre>
     *   S
     * </pre>
     * 
     * @param specification the specification to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setSpecification(byte[] specification) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_SPECIFICATION, 0x00, 0x00, specification);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set specification.");
            } else {
                throw new CardServiceException("Could not set specification.",
                        response.getSW());
            }
        }
    }

    /**
     * Get the application-specific specification: 
     * 
     * <pre>
     *   S
     * </pre>
     * 
     * @return the specification, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[] getSpecification() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_SPECIFICATION, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not get specification.");
                return null;
            } else {
                throw new CardServiceException("Could not get specification.",
                        response.getSW());
            }
        }

        return response.getData();
    }

    /**
     * Set the token attributes: 
     * 
     * <pre>
     *   A_1, ..., A_n
     * </pre>
     * 
     * @param attributes the token attributes to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setAttributes(byte[][] attributes) 
    throws CardServiceException {
        for (int i = 0; i < attributes.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_ATTRIBUTES, i + 1, attributes.length, 
                    attributes[i]);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not set token attributes.");
                } else {				
                    throw new CardServiceException("Could not set token " +
                            "attribute (@index " + (i + 1) + ").", 
                            response.getSW());
                }
            }	    
        }
    }

    /**
     * Get the number of attributes available.
     * 
     * @return the number of attributes.
     * @throws CardServiceException if an error occurred.
     */
    public int getNumberOfAttributes() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_NUMBER_OF_ATTRIBUTES, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            throw new CardServiceException("Could not get number of " +
                    "attributes.", response.getSW());
        }

        return response.getData()[0];
    }

    /**
     * Get the token attributes: 
     * 
     * <pre>
     *   A_1, ..., A_n
     * </pre>
     * 
     * @return the token attributes, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[][] getAttributes() 
    throws CardServiceException {
        byte[][] attributes = new byte[getNumberOfAttributes()][]; 

        for (int i = 0; i < attributes.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_GET_ATTRIBUTES, i + 1, attributes.length);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not get token attributes.");
                    return null;
                } else {
                    throw new CardServiceException("Could not get token " +
                            "attribute (@index " + (i + 1) + ").", 
                            response.getSW());
                }
            }
            attributes[i] = response.getData();
        }

        return attributes;
    }

    /**
     * Set the token attribute values: 
     * 
     * <pre>
     *   x_1, ..., x_n, x_t
     * </pre>
     * 
     * @param attributeValues the token attribute values to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setAttributeValues(byte[][] attributeValues) 
    throws CardServiceException {
        for (int i = 0; i < attributeValues.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_SET_ATTRIBUTE_VALUES, i + 1, attributeValues.length, 
                    fixLength(attributeValues[i]));
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not set token attribute values.");
                } else {
                    throw new CardServiceException("Could not set token " +
                            "attribute value (@index " + i + ").", 
                            response.getSW());
                }
            }	    
        }
    }

    /**
     * Get the token attribute values: 
     * 
     * <pre>
     *   x_1, ..., x_n, x_t
     * </pre>
     * 
     * @return the token attribute values, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[][] getAttributeValues() 
    throws CardServiceException {
        byte[][] values = new byte[getNumberOfAttributes()][]; 

        for (int i = 0; i < values.length; i++) {
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_GET_ATTRIBUTE_VALUES, i + 1, values.length);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not get token attribute values.");
                    return null;
                } else {
                    throw new CardServiceException("Could not get token " +
                            "attribute value (@index " + (i + 1) + ").", 
                            response.getSW());
                }
            }
            values[i] = response.getData();
        }

        return values;
    }

    /**
     * Set the token information field: 
     * 
     * <pre>
     *   TI
     * </pre>
     * 
     * @param tokenInformation the token information to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setTokenInformation(byte[] tokenInformation) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_TOKEN_INFORMATION, 0x00, 0x00, tokenInformation);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set token information.");
            } else {
                throw new CardServiceException("Could not set token " +
                        "information.",	response.getSW());
            }
        }	
    }

    /**
     * Get the token information field: 
     * 
     * <pre>
     *   TI
     * </pre>
     * 
     * @return the token information, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[] getTokenInformation() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_TOKEN_INFORMATION, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set token information.");
                return null;
            } else {
                throw new CardServiceException("Could not set token " +
                        "information.", response.getSW());
            }
        }

        return response.getData();
    }

    /**
     * Set the prover information field: 
     * 
     * <pre>
     *   PI 
     * </pre>
     * 
     * @param proverInformation the prover information to be set.
     * @throws CardServiceException if an error occurred.
     */
    void setProverInformation(byte[] proverInformation) 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SET_PROVER_INFORMATION, 0x00, 0x00, proverInformation);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set prover information.");
            } else {
                throw new CardServiceException("Could not set prover " +
                        "information.",	response.getSW());
            }
        }
    }

    /**
     * Get the prover information field: 
     * 
     * <pre>
     *   PI 
     * </pre>
     * 
     * @return the prover information, or null if not supported.
     * @throws CardServiceException if an error occurred.
     */
    byte[] getProverInformation() 
    throws CardServiceException {
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_GET_PROVER_INFORMATION, 0x00, 0x00);
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            if (response.getSW() == 0x00006D00) {
                notSupported("Could not set prover information.");
                return null;
            } else {
                throw new CardServiceException("Could not set prover " +
                        "information.", response.getSW());
            }
        }

        return response.getData();
    }

    /**
     * Perform issuance precomputation. 
     * 
     * <pre>
     *   compute x_1, ..., x_n, x_t
     *   
     *   gamma := g_0 g_1^(x_1) ... g_n^(x_n) g_t^(x_t) mod p
     *   sigmaZ := z_0 z_1^(x_1) ... z_n^(x_n) z_t^(x_t) mod p
     *   
     *   generate alpha at random from Zq*
     *   generate beta_1, beta_2 at random from Zq
     *   
     *   h := gamma^alpha mod p
     *   sigmaZ' := sigmaZ^alpha mod p
     *   tA := g_0^(beta_1) g^(beta_2) mod p
     *   tB := sigmaZ'^(beta_1) h^(beta_2) mod p
     *   alphaINV := alpha^(-1) mod q
     * </pre>
     * 
     * This is the first operation that takes place in the protocol. This method
     * may be invoked to perform precomputation independently from generation of
     * the first issuance protocol message.
     * 
     * @throws IOException if an error occurred.
     * 
     * @implements Prover.precomputation()
     */
    public void precomputation() 
    throws IOException {
        try {
            CommandAPDU command_inputs = new CommandAPDU(CLA_UPROVE, 
                    INS_PRECOMPUTE_INPUTS, 0x00, 0x00);
            ResponseAPDU response_inputs = transmit(command_inputs);
            if (response_inputs.getSW() != 0x00009000) {
                if (response_inputs.getSW() == 0x00006D00) {
                    notSupported("Could not perform precomputation.");
                } else { 
                    throw new IOException("Could not perform precomputation.");
                }
            }       
            CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                    INS_PRECOMPUTE, 0x00, 0x00);
            ResponseAPDU response = transmit(command);
            if (response.getSW() != 0x00009000) {
                if (response.getSW() == 0x00006D00) {
                    notSupported("Could not perform precomputation.");
                } else { 
                    throw new IOException("Could not perform precomputation.");
                }
            }
        } catch (CardServiceException e) {
            throw new IOException(e);
        }
    }

    /**
     * Generate the second issuance message (sigmaC) as response to the first 
     * issuance message (sigmaA, sigmaB).
     * 
     * <pre>
     *   sigmaA' := tA sigmaA mod p
     *   sigmaB' := tB sigmaB^alpha mod p
     *   sigmaC' := H(h, PI, sigmaZ', sigmaA', sigmaB') mod q
     *   sigmaC := sigmaC' + beta_1 mod q
     * </pre>
     * 
     * @param message1 the first issuance message ([sigmaA, sigmaB]).
     * @return the second issuance message ([sigmaC]).
     * @throws IOException if an error occurred.
     * 
     * @implements Prover.generateSecondMessage(byte[][])
     */
    public byte[][] generateSecondMessage(byte[][] message1) 
    throws IOException {
        byte[][] message2 = new byte[1][];

        try {
            // send sigmaA
            CommandAPDU commit_a = new CommandAPDU(CLA_UPROVE, 
                    INS_COMMIT_SIGMA_A, 0x00, 0x00, fixLength(message1[0]));
            ResponseAPDU response_a = transmit(commit_a);
            if (response_a.getSW() != 0x00009000) {
                throw new IOException("Could not commit sigmaA.");
            }	    

            // send sigmaB and receive sigmaC
            CommandAPDU commit_b = new CommandAPDU(CLA_UPROVE, 
                    INS_COMMIT_SIGMA_B, 0x00, 0x00, fixLength(message1[1]));
            ResponseAPDU response_b = transmit(commit_b);
            if (response_b.getSW() != 0x00009000) {
                throw new IOException("Could not commit sigmaB.");
            }

            message2[0] = response_b.getData();
        } catch (CardServiceException e) {
            throw new IOException(e);
        }

        return message2;
    }

    /**
     * Generate the U-Prove keys (h, alphaINV) and tokens (UID_P, h, TI, PI, 
     * sigmaZ', sigmaC', sigmaR') using the third issuance message (sigmaR).
     * 
     * <pre>
     *   sigmaR' := sigmaR + beta_2 mod q
     * </pre>
     * 
     * Verify the signature (optional).
     * 
     * <pre>
     *   sigmaA' sigmaB' mod p == (g h)^sigmaR' (g_0 sigmaZ')^(-sigmaC') mod p
     * </pre>   
     * 
     * @param message3 the third issuance message ([sigmaR]).
     * @return null since we do not want to disclose U-Prove keys and tokens.
     * @throws IOException if an error occurred.
     * 
     * @implements Prover.generateTokens(byte[][])
     */
    public UProveKeyAndToken[] generateTokens(byte[][] message3) 
    throws IOException {
        try {
            generateTokens(message3, false);
        } catch (CardServiceException e) {
            throw new IOException(e);
        }

        // do NOT return any U-Prove keys and tokens
        return null;
    }

    /**
     * Generate the U-Prove keys (h, alphaINV) and tokens (UID_P, h, TI, PI, 
     * sigmaZ', sigmaC', sigmaR') using the third issuance message (sigmaR).
     * 
     * <pre>
     *   sigmaR' := sigmaR + beta_2 mod q
     * </pre>
     * 
     * Verify the signature (optional).
     * 
     * <pre>
     *   sigmaA' sigmaB' mod p == (g h)^sigmaR' (g_0 sigmaZ')^(-sigmaC') mod p   
     * </pre>
     * 
     * @param message3 the third issuance message ([sigmaR]).
     * @param verify whether or not to verify the signature.
     * @return null since we do not want to disclose U-Prove keys and tokens.
     * @throws IOException if an error occurred.
     * 
     * @implements Prover.generateTokens(byte[][])
     */
    public UProveKeyAndToken[] generateTokens(byte[][] message3, boolean verify) 
    throws CardServiceException {
        // send sigmaR
        CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                INS_SIGNATURE_SIGMA_R, verify ? 0x01 : 0x00, 0x00, 
                        fixLength(message3[0]));
        ResponseAPDU response = transmit(command);
        if (response.getSW() != 0x00009000) {
            throw new CardServiceException("Could not issue signature sigmaR.", 
                    response.getSW());
        }

        // do NOT return any U-Prove keys and tokens
        return null;
    }

    /**
     * Retrieve the U-Prove token (UID_P, h, TI, PI, sigmaZ', sigmaC', sigmaR')
     * from the card.
     * 
     * @return the U-Prove token stored on the card.
     * @throws CardServiceException if an error occurred.
     */
    public UProveToken getUProveToken() 
    throws CardServiceException {
        UProveToken token = new UProveToken();

        token.setIssuerParametersUID(getParametersUID());
        token.setTokenInformation(getTokenInformation());
        token.setProverInformation(getProverInformation());

        CommandAPDU command_h = new CommandAPDU(CLA_UPROVE, 
                INS_GET_TOKEN, P1_TOKEN_H, 4);
        ResponseAPDU response_h = transmit(command_h);
        if (response_h.getSW() != 0x00009000) {
            throw new CardServiceException("Could not get token public key.", 
                    response_h.getSW());
        }
        token.setPublicKey(response_h.getData());

        CommandAPDU command_z = new CommandAPDU(CLA_UPROVE, 
                INS_GET_TOKEN, P1_TOKEN_SIGMA_Z, 4);
        ResponseAPDU response_z = transmit(command_z);
        if (response_z.getSW() != 0x00009000) {
            throw new CardServiceException("Could not get token signature " +
                    "(sigma_z').", response_z.getSW());
        }
        token.setSigmaZ(response_z.getData());

        CommandAPDU command_c = new CommandAPDU(CLA_UPROVE, 
                INS_GET_TOKEN, P1_TOKEN_SIGMA_C, 4);
        ResponseAPDU response_c = transmit(command_c);
        if (response_c.getSW() != 0x00009000) {
            throw new CardServiceException("Could not get token signature " +
                    "(sigma_c').", response_c.getSW());
        }
        token.setSigmaC(response_c.getData());

        CommandAPDU command_r = new CommandAPDU(CLA_UPROVE, 
                INS_GET_TOKEN, P1_TOKEN_SIGMA_R, 4);
        ResponseAPDU response_r = transmit(command_r);
        if (response_r.getSW() != 0x00009000) {
            throw new CardServiceException("Could not get token signature " +
                    "(sigma_r').", response_r.getSW());
        }
        token.setSigmaR(response_r.getData());

        return token;
    }

    /**
     * Generate a subset (selection) presentation proof.
     * 
     * <pre>
     *   generate w_0 at random from Zq
     *   for each i not in D generate w_i at random from Zq
     *   a := H(h^(w_0) g_i^(w_i) ... mod p) for all i not in D
     *   c := GenerateChallenge(IP, T, a, m, D, {x_i | i in D})
     *   r_0 := c alphaINV + w_0 mod q
     *   for each i not in D r_i := -c x_i + w_i mod q 
     * </pre>
     * 
     * @param disclosed the list of disclosed token attribute indices D.
     * @param m the challenge message.
     * @return a proof (A_i for each i in D, a, r_0, r_i for each i not in D).
     * @throws CardServiceException if an error occurred.
     */
    public PresentationProof generateProof(int[] disclosed, byte[] m) 
    throws CardServiceException {
        // translate the int[] to a byte[] 
        Arrays.sort(disclosed);
        byte[] D = new byte[disclosed.length];
        for (int i = 0; i < disclosed.length; i++) {
            D[i] = (byte) disclosed[i];
        }

        // send the attribute disclosure selection
        CommandAPDU command_d = new CommandAPDU(CLA_UPROVE, 
                INS_ATTRIBUTE_DISCLOSURE, 0x00, 0x00, D);
        ResponseAPDU response_d = transmit(command_d);
        if (response_d.getSW() != 0x00009000) {
            throw new CardServiceException("Could not set attribute " +
                    "disclosure selection.", response_d.getSW());
        }

        // send the challenge
        CommandAPDU command_m = new CommandAPDU(CLA_UPROVE, 
                INS_CHALLENGE, 0x00, 0x00, m);
        ResponseAPDU response_a = transmit(command_m);
        if (response_a.getSW() != 0x00009000) {
            throw new CardServiceException("Could not set the challenge.", 
                    response_a.getSW());
        }

        // save the response a
        byte[] a = response_a.getData();	

        // retrieve both the A_i and r_i (including r_0) values
        int j = 0, length = getNumberOfAttributes();
        byte[] r0 = null;
        byte[][] r = new byte[length - disclosed.length][];
        byte[][] disclosedAttributes = new byte[disclosed.length][];
        for (int i = 0; i <= length; i++) {
            if (j < disclosed.length && disclosed[j] == i) {
                CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                        INS_DISCLOSED_ATTRIBUTES, i, length);
                ResponseAPDU response = transmit(command);
                if (response.getSW() != 0x00009000) {
                    throw new CardServiceException("Could not get disclosed " +
                            "attribute (@index " + i + ").", response.getSW());
                }
                disclosedAttributes[j++] = response.getData();
            } else {
                CommandAPDU command = new CommandAPDU(CLA_UPROVE, 
                        INS_UNDISCLOSED_ATTRIBUTES, i, length + 1);
                ResponseAPDU response = transmit(command);
                if (response.getSW() != 0x00009000) {
                    throw new CardServiceException("Could not get random " +
                            "value (@index " + i + ").", response.getSW());
                }
                if (i == 0) {
                    r0 = response.getData();
                } else {
                    r[i-j-1] = response.getData();
                }
            }
        }

        return new PresentationProof(disclosedAttributes, a, r0, r, null);
    }
}
